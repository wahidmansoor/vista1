// Client-side API wrapper for AI agent functionality
import { v4 as uuidv4 } from 'uuid';
import { ModuleType, PromptIntent, AIRequestBody, AIError, AIResponse } from '@/types/ai-agent';
import { z } from 'zod';

/**
 * Zod schema for LLM prompt validation.
 * - String, max 500 chars
 * - Only alphanumeric, whitespace, and . , ? ! -
 */
export const promptSchema = z.string().max(500).regex(/^[\w\s.,?!-]+$/);

// Mock response function for development/testing
const getOfflineResponse = (prompt: string, module: string): string => {
  return `This is a mock response for "${prompt}" from the ${module} module. When online, this would be generated by an AI model.`;
};

/**
 * Sends a request to the AI agent to generate a response based on the provided parameters.
 * 
 * @param options Request parameters for the AI agent
 * @returns A promise that resolves to the AI response
 */
export async function getAIResponse(options: AIRequestBody): Promise<AIResponse> {
  const { prompt, mockMode, module, intent, context, history } = options;
  
  // Validate prompt
  try {
    promptSchema.parse(prompt);
  } catch (validationError: any) {
    throw {
      name: 'ValidationError',
      message: 'Prompt validation failed',
      code: 'INVALID_PROMPT',
      details: validationError.errors || validationError.message
    } as AIError;
  }
  
  // For mock mode or development without real API connections
  if (mockMode || process.env.NODE_ENV === 'test') {
    return {
      id: uuidv4(),
      content: getOfflineResponse(prompt, module),
      timestamp: new Date().toISOString(),
      metadata: {
        module,
        intent,
        model: 'mock-model'
      }
    };
  }
  
  try {
    // Call to Netlify function endpoint
    const response = await fetch('/.netlify/functions/gemini-ai', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ prompt, context, history, module, intent }),
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw {
        name: 'APIError',
        message: errorData.error || 'Failed to get AI response',
        code: errorData.code || 'API_ERROR',
        statusCode: response.status,
        details: errorData.details
      } as AIError;
    }
    
    return await response.json();
  } catch (error) {
    if ((error as AIError).code) {
      throw error;
    }
    
    throw {
      name: 'NetworkError',
      message: 'Failed to communicate with AI service',
      code: 'NETWORK_ERROR',
      details: (error as Error).message
    } as AIError;
  }
}